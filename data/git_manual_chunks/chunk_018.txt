attempts to merge the new head in to their branch, Git will attempt to merge together the two (old and new) lines of development, instead of trying to replace the old by the new. The results are likely to be unexpected. You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work. For true distributed development that supports proper merging, published branches should never be rewritten. Why bisecting merge commits can be harder than bisecting linear history The git-bisect[1] command correctly handles history that includes merge commits. However, when the commit that it finds is a merge commit, the user may need to work harder than usual to figure out why that commit introduced a problem. Imagine this history: ---Z---o---X---...---o---A---C---D \ / o---o---Y---...---o---B Suppose that on the upper line of development, the meaning of one of the functions that exists at Z is changed at commit X. The commits from Z leading to A change both the function’s implementation and all calling sites that exist at Z, as well as new calling sites they add, to be consistent. There is no bug at A. Suppose that in the meantime on the lower line of development somebody adds a new calling site for that function at commit Y. The commits from Z leading to B all assume the old semantics of that function and the callers and the callee are consistent with each other. There is no bug at B, either. Suppose further that the two development lines merge cleanly at C, so no conflict resolution is required. Nevertheless, the code at C is broken, because the callers added on the lower line of development have not been converted to the new semantics introduced on the upper line of development. So if all you know is that D is bad, that Z is good, and that git-bisect[1] identifies C as the culprit, how will you figure out that the problem is due to this change in semantics? When the result of a git bisect is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won’t help in the case above, however, because the problem isn’t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development. On the other hand, if instead of merging at C you had rebased the history between Z to B on top of A, you would have gotten this linear history: ---Z---o---X--...---o---A---o---o---Y*--...---o---B*--D* Bisecting between Z and D* would hit a single culprit commit Y*, and understanding why Y* was broken would probably be easier. Partly for this reason, many experienced Git users, even when working on an otherwise merge-heavy project, keep the history linear by rebasing against the latest upstream version before publishing. Advanced branch management Fetching individual branches Instead of using git-remote[1] , you can also choose just to update one branch at a time, and to store it locally under an arbitrary name: $ git fetch origin todo:my-todo-work The first argument, origin , just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named todo from the remote repository, and to store it locally under the name refs/heads/my-todo-work . You can also fetch branches from other repositories; so $ git fetch git://example.com/proj.git master:example-master will create a new branch named example-master and store in it the branch named master from the repository at the given URL. If you already have a branch named example-master, it will attempt to fast-forward to the commit given by example.com’s master branch. In more detail: git fetch and fast-forwards In the previous example, when updating an existing branch, git fetch checks to make sure that the most recent commit on the remote branch is a descendant of the most recent commit on your copy of the branch before updating your copy of the branch to point at the new commit. Git calls this process a fast-forward . A fast-forward looks something like this: o--o--o--o <-- old head of the branch \ o--o--o <-- new head of the branch In some cases it is possible that the new head will not actually be a descendant of the old head. For example, the developer may have realized a serious mistake was made and decided to backtrack, resulting in a situation like: o--o--o--o--a--b <--