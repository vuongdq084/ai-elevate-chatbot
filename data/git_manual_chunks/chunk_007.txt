archive -o latest.tar.gz --prefix=project/ HEAD will use HEAD to produce a gzipped tar archive in which each filename is preceded by project/ . The output file format is inferred from the output file extension if possible, see git-archive[1] for details. Versions of Git older than 1.7.7 don’t know about the tar.gz format, you’ll need to use gzip explicitly: $ git archive --format=tar --prefix=project/ HEAD | gzip >latest.tar.gz If you’re releasing a new version of a software project, you may want to simultaneously make a changelog to include in the release announcement. Linus Torvalds, for example, makes new kernel releases by tagging them, then running: $ release-script 2.6.12 2.6.13-rc6 2.6.13-rc7 where release-script is a shell script that looks like: #!/bin/sh stable="$1" last="$2" new="$3" echo "# git tag v$new" echo "git archive --prefix=linux-$new/ v$new | gzip -9 > ../linux-$new.tar.gz" echo "git diff v$stable v$new | gzip -9 > ../patch-$new.gz" echo "git log --no-merges v$new ^v$last > ../ChangeLog-$new" echo "git shortlog --no-merges v$new ^v$last > ../ShortLog" echo "git diff --stat --summary -M v$last v$new > ../diffstat-$new" and then he just cut-and-pastes the output commands after verifying that they look OK. Finding commits referencing a file with given content Somebody hands you a copy of a file, and asks which commits modified a file such that it contained the given content either before or after the commit. You can find out with this: $ git log --raw --abbrev=40 --pretty=oneline | grep -B 1 `git hash-object filename` Figuring out why this works is left as an exercise to the (advanced) student. The git-log[1] , git-diff-tree[1] , and git-hash-object[1] man pages may prove helpful. Developing with Git Telling Git your name Before creating any commits, you should introduce yourself to Git. The easiest way to do so is to use git-config[1] : $ git config --global user.name 'Your Name Comes Here' $ git config --global user.email 'you@yourdomain.example.com' Which will add the following to a file named .gitconfig in your home directory: [user] name = Your Name Comes Here email = you@yourdomain.example.com See the "CONFIGURATION FILE" section of git-config[1] for details on the configuration file. The file is plain text, so you can also edit it with your favorite editor. Creating a new repository Creating a new repository from scratch is very easy: $ mkdir project $ cd project $ git init If you have some initial content (say, a tarball): $ tar xzvf project.tar.gz $ cd project $ git init $ git add . # include everything below ./ in the first commit: $ git commit How to make a commit Creating a new commit takes three steps: Making some changes to the working directory using your favorite editor. Telling Git about your changes. Creating the commit using the content you told Git about in step 2. In practice, you can interleave and repeat steps 1 and 2 as many times as you want: in order to keep track of what you want committed at step 3, Git maintains a snapshot of the tree’s contents in a special staging area called "the index." At the beginning, the content of the index will be identical to that of the HEAD. The command git diff --cached , which shows the difference between the HEAD and the index, should therefore produce no output at that point. Modifying the index is easy: To update the index with the contents of a new or modified file, use $ git add path/to/file To remove a file from the index and from the working tree, use $ git rm path/to/file After each step you can verify that $ git diff --cached always shows the difference between the HEAD and the index file—​this is what you’d commit if you created the commit now—​and that $ git diff shows the difference between the working tree and the index file. Note that git add always adds just the current contents of a file to the index; further changes to the same file will be ignored unless you run git add on the file again. When you’re ready, just run $ git commit and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with $ git show As a special shortcut, $ git commit -a will update the index with any files that you’ve modified or removed and create a commit, all in one step. A number of commands are useful for keeping track of what you’re about to commit: $ git diff --cached # difference between HEAD and the index; what # would be committed if you ran "commit" now. $ git diff # difference between the index file and your # working directory; changes that would not # be included if you ran "commit" now. $ git diff HEAD #