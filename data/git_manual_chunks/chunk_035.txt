corresponding to the revision 's top directory . The following are all tree-ishes: a commit-ish , a tree object, a tag object that points to a tree object, a tag object that points to a tag object that points to a tree object, etc. unborn The HEAD can point at a branch that does not yet exist and that does not have any commit on it yet, and such a branch is called an unborn branch. The most typical way users encounter an unborn branch is by creating a repository anew without cloning from elsewhere. The HEAD would point at the main (or master , depending on your configuration) branch that is yet to be born. Also some operations can get you on an unborn branch with their orphan option. unmerged index An index which contains unmerged index entries . unreachable object An object which is not reachable from a branch , tag , or any other reference. upstream branch The default branch that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.<name>.remote and branch.<name>.merge. If the upstream branch of A is origin/B sometimes we say " A is tracking origin/B ". working tree The tree of actual checked out files. The working tree normally contains the contents of the HEAD commitâ€™s tree, plus any local changes that you have made but not yet committed. worktree A repository can have zero (i.e. bare repository) or one or more worktrees attached to it. One "worktree" consists of a "working tree" and repository metadata, most of which are shared among other worktrees of a single repository, and some of which are maintained separately per worktree (e.g. the index, HEAD and pseudorefs like MERGE_HEAD, per-worktree refs and per-worktree configuration file). Appendix A: Git Quick Reference This is a quick summary of the major commands; the previous chapters explain how these work in more detail. Creating a new repository From a tarball: $ tar xzf project.tar.gz $ cd project $ git init Initialized empty Git repository in .git/ $ git add . $ git commit From a remote repository: $ git clone git://example.com/pub/project.git $ cd project Managing branches $ git branch # list all local branches in this repo $ git switch test # switch working directory to branch "test" $ git branch new # create branch "new" starting at current HEAD $ git branch -d new # delete branch "new" Instead of basing a new branch on current HEAD (the default), use: $ git branch new test # branch named "test" $ git branch new v2.6.15 # tag named v2.6.15 $ git branch new HEAD^ # commit before the most recent $ git branch new HEAD^^ # commit before that $ git branch new test~10 # ten commits before tip of branch "test" Create and switch to a new branch at the same time: $ git switch -c new v2.6.15 Update and examine branches from the repository you cloned from: $ git fetch # update $ git branch -r # list origin/master origin/next ... $ git switch -c masterwork origin/master Fetch a branch from a different repository, and give it a new name in your repository: $ git fetch git://example.com/project.git theirbranch:mybranch $ git fetch git://example.com/project.git v2.6.15:mybranch Keep a list of repositories you work with regularly: $ git remote add example git://example.com/project.git $ git remote # list remote repositories example origin $ git remote show example # get details * remote example URL: git://example.com/project.git Tracked remote branches master next ... $ git fetch example # update branches from example $ git branch -r # list all remote branches Exploring history $ gitk # visualize and browse history $ git log # list all commits $ git log src/ # ...modifying src/ $ git log v2.6.15..v2.6.16 # ...in v2.6.16, not in v2.6.15 $ git log master..test # ...in branch test, not in branch master $ git log test..master # ...in branch master, but not in test $ git log test...master # ...in one branch, not in both $ git log -S'foo()' # ...where difference contain "foo()" $ git log --since="2 weeks ago" $ git log -p # show patches as well $ git show # most recent commit $ git diff v2.6.15..v2.6.16 # diff between two tagged versions $ git diff v2.6.15..HEAD # diff with current head $ git grep "foo()" # search working directory for "foo()" $ git grep v2.6.15 "foo()" # search old tree for "foo()" $ git show v2.6.15:a.txt # look at old version of a.txt Search for regressions: $ git bisect start $ git bisect bad # current version is bad $ git bisect good v2.6.13-rc2 # last known good revision Bisecting: 675 revisions left to test after this # test here, then: $ git bisect good # if this