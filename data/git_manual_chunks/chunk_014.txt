commits (as in Fixing a mistake by rewriting history ), or use git rebase to rebase any already-published commits (as in Keeping a patch series up to date using git rebase ). You may force git push to perform the update anyway by preceding the branch name with a plus sign: $ git push ssh://yourserver.com/~you/proj.git +master Note the addition of the + sign. Alternatively, you can use the -f flag to force the remote update, as in: $ git push -f ssh://yourserver.com/~you/proj.git master Normally whenever a branch head in a public repository is modified, it is modified to point to a descendant of the commit that it pointed to before. By forcing a push in this situation, you break that convention. (See Problems with rewriting history .) Nevertheless, this is a common practice for people that need a simple way to publish a work-in-progress patch series, and it is an acceptable compromise as long as you warn other developers that this is how you intend to manage the branch. It’s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the next section and gitcvs-migration[7] for more. Setting up a shared repository Another way to collaborate is by using a model similar to that commonly used in CVS, where several developers with special rights all push to and pull from a single shared repository. See gitcvs-migration[7] for instructions on how to set this up. However, while there is nothing wrong with Git’s support for shared repositories, this mode of operation is not generally recommended, simply because the mode of collaboration that Git supports—​by exchanging patches and pulling from public repositories—​has so many advantages over the central shared repository: Git’s ability to quickly import and merge patches allows a single maintainer to process incoming changes even at very high rates. And when that becomes too much, git pull provides an easy way for that maintainer to delegate this job to other maintainers while still allowing optional review of incoming changes. Since every developer’s repository has the same complete copy of the project history, no repository is special, and it is trivial for another developer to take over maintenance of a project, either by mutual agreement, or because a maintainer becomes unresponsive or difficult to work with. The lack of a central group of "committers" means there is less need for formal decisions about who is "in" and who is "out". Allowing web browsing of a repository The gitweb cgi script provides users an easy way to browse your project’s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled. The git-instaweb[1] command provides a simple way to start browsing the repository using gitweb. The default server when using instaweb is lighttpd. See the file gitweb/INSTALL in the Git source tree and gitweb[1] for instructions on details setting up a permanent installation with a CGI or Perl capable server. How to get a Git repository with minimal history A shallow clone , with its truncated history, is useful when one is interested only in recent history of a project and getting full history from the upstream is expensive. A shallow clone is created by specifying the git-clone[1] --depth switch. The depth can later be changed with the git-fetch[1] --depth switch, or full history restored with --unshallow . Merging inside a shallow clone will work as long as a merge base is in the recent history. Otherwise, it will be like merging unrelated histories and may have to result in huge conflicts. This limitation may make such a repository unsuitable to be used in merge based workflows. Examples Maintaining topic branches for a Linux subsystem maintainer This describes how Tony Luck uses Git in his role as maintainer of the IA64 architecture for the Linux kernel. He uses two public branches: A "test" tree into which patches are initially placed so that they can get some exposure when integrated with other ongoing development. This tree is available to Andrew for pulling into -mm whenever he wants. A "release" tree into which tested patches are moved for final sanity checking, and as a vehicle to send them upstream to Linus (by sending him a "please pull" request.) He also uses a set of temporary branches ("topic branches"), each containing a logical grouping of patches. To set this up, first create your work tree by cloning Linus’s public tree: $ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git work $ cd work Linus’s tree will be stored in the remote-tracking branch named origin/master, and can be updated using