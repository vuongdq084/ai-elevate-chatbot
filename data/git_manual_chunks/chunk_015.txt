git-fetch[1] ; you can track other public trees using git-remote[1] to set up a "remote" and git-fetch[1] to keep them up to date; see Repositories and Branches . Now create the branches in which you are going to work; these start out at the current tip of origin/master branch, and should be set up (using the --track option to git-branch[1] ) to merge changes in from Linus by default. $ git branch --track test origin/master $ git branch --track release origin/master These can be easily kept up to date using git-pull[1] . $ git switch test && git pull $ git switch release && git pull Important note! If you have any local changes in these branches, then this merge will create a commit object in the history (with no local changes Git will simply do a "fast-forward" merge). Many people dislike the "noise" that this creates in the Linux history, so you should avoid doing this capriciously in the release branch, as these noisy commits will become part of the permanent history when you ask Linus to pull from the release branch. A few configuration variables (see git-config[1] ) can make it easy to push both branches to your public tree. (See Setting up a public repository .) $ cat >> .git/config <<EOF [remote "mytree"] url = master.kernel.org:/pub/scm/linux/kernel/git/aegl/linux.git push = release push = test EOF Then you can push both the test and release trees using git-push[1] : $ git push mytree or push just one of the test and release branches using: $ git push mytree test or $ git push mytree release Now to apply some patches from the community. Think of a short snappy name for a branch to hold this patch (or related group of patches), and create a new branch from a recent stable tag of Linus’s branch. Picking a stable base for your branch will: 1) help you: by avoiding inclusion of unrelated and perhaps lightly tested changes 2) help future bug hunters that use git bisect to find problems $ git switch -c speed-up-spinlocks v2.6.35 Now you apply the patch(es), run some tests, and commit the change(s). If the patch is a multi-part series, then you should apply each as a separate commit to this branch. $ ... patch ... test ... commit [ ... patch ... test ... commit ]* When you are happy with the state of this change, you can merge it into the "test" branch in preparation to make it public: $ git switch test && git merge speed-up-spinlocks It is unlikely that you would have any conflicts here …​ but you might if you spent a while on this step and had also pulled new versions from upstream. Sometime later when enough time has passed and testing done, you can pull the same branch into the release tree ready to go upstream. This is where you see the value of keeping each patch (or patch series) in its own branch. It means that the patches can be moved into the release tree in any order. $ git switch release && git merge speed-up-spinlocks After a while, you will have a number of branches, and despite the well chosen names you picked for each of them, you may forget what they are for, or what status they are in. To get a reminder of what changes are in a specific branch, use: $ git log linux..branchname | git shortlog To see whether it has already been merged into the test or release branches, use: $ git log test..branchname or $ git log release..branchname (If this branch has not yet been merged, you will see some log entries. If it has been merged, then there will be no output.) Once a patch completes the great cycle (moving from test to release, then pulled by Linus, and finally coming back into your local origin/master branch), the branch for this change is no longer needed. You detect this when the output from: $ git log origin..branchname is empty. At this point the branch can be deleted: $ git branch -d branchname Some changes are so trivial that it is not necessary to create a separate branch and then merge into each of the test and release branches. For these changes, just apply directly to the release branch, and then merge that into the test branch. After pushing your work to mytree , you can use git-request-pull[1] to prepare a "please pull" request message to send to Linus: $ git push mytree $ git request-pull origin mytree release Here are some of the scripts that simplify all this even further. ==== update script ==== # Update a branch in my Git tree. If the branch to be updated # is origin, then pull from kernel.org. Otherwise merge # origin/master branch into test|release