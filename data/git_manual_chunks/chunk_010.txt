that file will be "collapsed", after which git diff will (by default) no longer show diffs for that file. Undoing a merge If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with $ git merge --abort Or, if you’ve already committed the merge that you want to throw away, $ git reset --hard ORIG_HEAD However, this last command can be dangerous in some cases—​never throw away a commit you have already committed if that commit may itself have been merged into another branch, as doing so may confuse further merges. Fast-forward merges There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged. However, if the current branch is an ancestor of the other—​so every commit present in the current branch is already contained in the other branch—​then Git just performs a "fast-forward"; the head of the current branch is moved forward to point at the head of the merged-in branch, without any new commits being created. Fixing mistakes If you’ve messed up the working tree, but haven’t yet committed your mistake, you can return the entire working tree to the last committed state with $ git restore --staged --worktree :/ If you make a commit that you later wish you hadn’t, there are two fundamentally different ways to fix the problem: You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public. You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the "history" of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed. Fixing a mistake with a new commit Creating a new commit that reverts an earlier change is very easy; just pass the git-revert[1] command a reference to the bad commit; for example, to revert the most recent commit: $ git revert HEAD This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit. You can also revert an earlier change, for example, the next-to-last: $ git revert HEAD^ In this case Git will attempt to undo the old change while leaving intact any changes made since then. If more recent changes overlap with the changes to be reverted, then you will be asked to fix conflicts manually, just as in the case of resolving a merge . Fixing a mistake by rewriting history If the problematic commit is the most recent commit, and you have not yet made that commit public, then you may just destroy it using git reset . Alternatively, you can edit the working directory and update the index to fix your mistake, just as if you were going to create a new commit , then run $ git commit --amend which will replace the old commit by a new commit incorporating your changes, giving you a chance to edit the old commit message first. Again, you should never do this to a commit that may already have been merged into another branch; use git-revert[1] instead in that case. It is also possible to replace commits further back in the history, but this is an advanced topic to be left for another chapter . Checking out an old version of a file In the process of undoing a previous bad change, you may find it useful to check out an older version of a particular file using git-restore[1] . The command $ git restore --source=HEAD^ path/to/file replaces path/to/file by the contents it had in the commit HEAD^, and also updates the index to match. It does not change branches. If you just want to look at an old version of the file, without modifying the working directory, you can do that with git-show[1] : $ git show HEAD^:path/to/file which will display the given version of the file. Temporarily setting aside work in progress While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use git-stash[1] to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes. $ git stash push -m "work in progress for foo feature" This command will save your changes away to the stash , and reset your working tree