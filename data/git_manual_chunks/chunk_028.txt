start is with the contents of the initial commit, with: $ git switch --detach e83c5163 The initial revision lays the foundation for almost everything Git has today (even though details may differ in a few places), but is small enough to read in one sitting. Note that terminology has changed since that revision. For example, the README in that revision uses the word "changeset" to describe what we now call a commit . Also, we do not call it "cache" any more, but rather "index"; however, the file is still called read-cache.h . If you grasp the ideas in that initial commit, you should check out a more recent version and skim read-cache-ll.h , object.h and commit.h . In the early days, Git (in the tradition of UNIX) was a bunch of programs which were extremely simple, and which you used in scripts, piping the output of one into another. This turned out to be good for initial development, since it was easier to test new things. However, recently many of these parts have become builtins, and some of the core has been "libified", i.e. put into libgit.a for performance, portability reasons, and to avoid code duplication. By now, you know what the index is (and find the corresponding data structures in read-cache-ll.h ), and that there are just a couple of object types (blobs, trees, commits and tags) which inherit their common structure from struct object , which is their first member (and thus, you can cast e.g. ( struct object * ) commit to achieve the same as &commit->object , i.e. get at the object name and flags). Now is a good point to take a break to let this information sink in. Next step: get familiar with the object naming. Read Naming commits . There are quite a few ways to name an object (and not only revisions!). All of these are handled in sha1_name.c . Just have a quick look at the function get_sha1 () . A lot of the special handling is done by functions like get_sha1_basic () or the likes. This is just to get you into the groove for the most libified part of Git: the revision walker. Basically, the initial version of git log was a shell script: $ git-rev-list --pretty $(git-rev-parse --default HEAD "$@") | \ LESS=-S ${PAGER:-less} What does this mean? git rev-list is the original version of the revision walker, which always printed a list of revisions to stdout. It is still functional, and needs to, since most new Git commands start out as scripts using git rev-list . git rev-parse is not as important any more; it was only used to filter out options that were relevant for the different plumbing commands that were called by the script. Most of what git rev-list did is contained in revision.c and revision.h . It wraps the options in a struct named rev_info , which controls how and what revisions are walked, and more. The original job of git rev-parse is now taken by the function setup_revisions () , which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct rev_info for later consumption. You can do your own command-line option parsing after calling setup_revisions () . After that, you have to call prepare_revision_walk () for initialization, and then you can get the commits one by one with the function get_revision () . If you are interested in more details of the revision walking process, just have a look at the first implementation of cmd_log () ; call git show v1.3.0~155^2~4 and scroll down to that function (note that you no longer need to call setup_pager () directly). Nowadays, git log is a builtin, which means that it is contained in the command git . The source side of a builtin is a function called cmd_ <bla> , typically defined in builtin/<bla.c> (note that older versions of Git used to have it in builtin- <bla> .c instead), and declared in builtin.h . an entry in the commands [] array in git.c , and an entry in BUILTIN_OBJECTS in the Makefile . Sometimes, more than one builtin is contained in one source file. For example, cmd_whatchanged () and cmd_log () both reside in builtin/log.c , since they share quite a bit of code. In that case, the commands which are not named like the .c file in which they live have to be listed in BUILT_INS in the Makefile . git log looks more complicated in C than it does in the original script, but that allows for a much greater flexibility and performance. Here again it is a good point to take a pause. Lesson three is: study the code. Really, it is the best way to learn about the organization of