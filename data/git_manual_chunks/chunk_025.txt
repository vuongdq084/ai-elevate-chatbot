branch. Low-level Git operations Many of the higher-level commands were originally implemented as shell scripts using a smaller core of low-level Git commands. These can still be useful when doing unusual things with Git, or just as a way to understand its inner workings. Object access and manipulation The git-cat-file[1] command can show the contents of any object, though the higher-level git-show[1] is usually more useful. The git-commit-tree[1] command allows constructing commits with arbitrary parents and trees. A tree can be created with git-write-tree[1] and its data can be accessed by git-ls-tree[1] . Two trees can be compared with git-diff-tree[1] . A tag is created with git-mktag[1] , and the signature can be verified by git-verify-tag[1] , though it is normally simpler to use git-tag[1] for both. The Workflow High-level operations such as git-commit[1] and git-restore[1] work by moving data between the working tree, the index, and the object database. Git provides low-level operations which perform each of these steps individually. Generally, all Git operations work on the index file. Some operations work purely on the index file (showing the current state of the index), but most operations move data between the index file and either the database or the working directory. Thus there are four main combinations: working directory → index The git-update-index[1] command updates the index with information from the working directory. You generally update the index information by just specifying the filename you want to update, like so: $ git update-index filename but to avoid common mistakes with filename globbing etc., the command will not normally add totally new entries or remove old entries, i.e. it will normally just update existing cache entries. To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the --remove and --add flags respectively. NOTE! A --remove flag does not mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing --remove means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly. As a special case, you can also do git update-index --refresh , which will refresh the "stat" information of each index to match the current stat information. It will not update the object status itself, and it will only update the fields that are used to quickly test whether an object still matches its old backing store object. The previously introduced git-add[1] is just a wrapper for git-update-index[1] . index → object database You write your current index file to a "tree" object with the program $ git write-tree that doesn’t come with any options—​it will just write out the current index into the set of tree objects that describe that state, and it will return the name of the resulting top-level tree. You can use that tree to re-generate the index at any time by going in the other direction: object database → index You read a "tree" file from the object database, and use that to populate (and overwrite—​don’t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just $ git read-tree <SHA-1 of tree> and your index file will now be equivalent to the tree that you saved earlier. However, that is only your index file: your working directory contents have not been modified. index → working directory You update your working directory from the index by "checking out" files. This is not a very common operation, since normally you’d just keep your files updated, and rather than write to your working directory, you’d tell the index files about the changes in your working directory (i.e. git update-index ). However, if you decide to jump to a new version, or check out somebody else’s version, or just restore a previous tree, you’d populate your index file with read-tree, and then you need to check out the result with $ git checkout-index filename or, if you want to check out all of the index, use -a . NOTE! git checkout-index normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the -f flag ( before the -a flag or the filename) to force the checkout. Finally, there are a few odds and ends which are not purely moving from one representation to the other: Tying it all together To commit a tree you have instantiated with git write-tree , you’d create a "commit" object that refers to that tree and the history behind it—​most notably