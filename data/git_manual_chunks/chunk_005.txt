just want to tell Git that you want to skip the current commit: $ git bisect skip In this case, though, Git may not eventually be able to tell the first bad one between some first skipped commits and a later bad commit. There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See git-bisect[1] for more information about this and other git bisect features. Naming commits We have seen several ways of naming commits already: 40-hexdigit object name branch name: refers to the commit at the head of the given branch tag name: refers to the commit pointed to by the given tag (we’ve seen branches and tags are special cases of references ). HEAD: refers to the head of the current branch There are many more; see the "SPECIFYING REVISIONS" section of the gitrevisions[7] man page for the complete list of ways to name revisions. Some examples: $ git show fb47ddb2 # the first few characters of the object name # are usually enough to specify it uniquely $ git show HEAD^ # the parent of the HEAD commit $ git show HEAD^^ # the grandparent $ git show HEAD~4 # the great-great-grandparent Recall that merge commits may have more than one parent; by default, ^ and ~ follow the first parent listed in the commit, but you can also choose: $ git show HEAD^1 # show the first parent of HEAD $ git show HEAD^2 # show the second parent of HEAD In addition to HEAD, there are several other special names for commits: Merges (to be discussed later), as well as operations such as git reset , which change the currently checked-out commit, generally set ORIG_HEAD to the value HEAD had before the current operation. The git fetch operation always stores the head of the last fetched branch in FETCH_HEAD. For example, if you run git fetch without specifying a local branch as the target of the operation $ git fetch git://example.com/proj.git theirbranch the fetched commits will still be available from FETCH_HEAD. When we discuss merges we’ll also see the special name MERGE_HEAD, which refers to the other branch that we’re merging in to the current branch. The git-rev-parse[1] command is a low-level command that is occasionally useful for translating some name for a commit to the object name for that commit: $ git rev-parse origin e05db0fd4f31dde7005f075a84f96b360d05984b Creating tags We can also create a tag to refer to a particular commit; after running $ git tag stable-1 1b2e1d63ff You can use stable-1 to refer to the commit 1b2e1d63ff. This creates a "lightweight" tag. If you would also like to include a comment with the tag, and possibly sign it cryptographically, then you should create a tag object instead; see the git-tag[1] man page for details. Browsing revisions The git-log[1] command can show lists of commits. On its own, it shows all commits reachable from the parent commit; but you can also make more specific requests: $ git log v2.5.. # commits since (not reachable from) v2.5 $ git log test..master # commits reachable from master but not test $ git log master..test # ...reachable from test but not master $ git log master...test # ...reachable from either test or master, # but not both $ git log --since="2 weeks ago" # commits from the last 2 weeks $ git log Makefile # commits which modify Makefile $ git log fs/ # ... which modify any file under fs/ $ git log -S'foo()' # commits which add or remove any file data # matching the string 'foo()' And of course you can combine all of these; the following finds commits since v2.5 which touch the Makefile or any file under fs : $ git log v2.5.. Makefile fs/ You can also ask git log to show patches: $ git log -p See the --pretty option in the git-log[1] man page for more display options. Note that git log starts with the most recent commit and works backwards through the parents; however, since Git history can contain multiple independent lines of development, the particular order that commits are listed in may be somewhat arbitrary. Generating diffs You can generate diffs between any two versions using git-diff[1] : $ git diff master..test That will produce the diff between the tips of the two branches. If you’d prefer to find the diff from their common ancestor to test, you can use three dots instead of two: $ git diff master...test Sometimes what you want instead is a set of patches; for this you can use git-format-patch[1] : $ git format-patch master..test will generate a file with a patch for each commit reachable from test but not from master. Viewing old file versions You can always view