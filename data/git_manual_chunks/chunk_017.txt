those contents, and then, instead of running git commit , just run $ git rebase --continue and Git will continue applying the rest of the patches. At any point you may use the --abort option to abort this process and return mywork to the state it had before you started the rebase: $ git rebase --abort If you need to reorder or edit a number of commits in a branch, it may be easier to use git rebase -i , which allows you to reorder and squash commits, as well as marking them for individual editing during the rebase. See Using interactive rebases for details, and Reordering or selecting from a patch series for alternatives. Rewriting a single commit We saw in Fixing a mistake by rewriting history that you can replace the most recent commit using $ git commit --amend which will replace the old commit by a new commit incorporating your changes, giving you a chance to edit the old commit message first. This is useful for fixing typos in your last commit, or for adjusting the patch contents of a poorly staged commit. If you need to amend commits from deeper in your history, you can use interactive rebaseâ€™s edit instruction . Reordering or selecting from a patch series Sometimes you want to edit a commit deeper in your history. One approach is to use git format-patch to create a series of patches and then reset the state to before the patches: $ git format-patch origin $ git reset --hard origin Then modify, reorder, or eliminate patches as needed before applying them again with git-am[1] : $ git am *.patch Using interactive rebases You can also edit a patch series with an interactive rebase. This is the same as reordering a patch series using format-patch , so use whichever interface you like best. Rebase your current HEAD on the last commit you want to retain as-is. For example, if you want to reorder the last 5 commits, use: $ git rebase -i HEAD~5 This will open your editor with a list of steps to be taken to perform your rebase. pick deadbee The oneline of this commit pick fa1afe1 The oneline of the next commit ... # Rebase c0ffeee..deadbee onto c0ffeee # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like "squash", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out As explained in the comments, you can reorder commits, squash them together, edit commit messages, etc. by editing the list. Once you are satisfied, save the list and close your editor, and the rebase will begin. The rebase will stop where pick has been replaced with edit or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with git rebase --continue . If you decide that things are getting too hairy, you can always bail out with git rebase --abort . Even after the rebase is complete, you can still recover the original branch by using the reflog . For a more detailed discussion of the procedure and additional tips, see the "INTERACTIVE MODE" section of git-rebase[1] . Other tools There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual. Problems with rewriting history The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this: o--o--O--o--o--o <-- origin \ \ t--t--t--m <-- their branch: Then suppose you modify the last three commits: o--o--o <-- new head of origin / o--o--O--o--o--o <-- old head of origin If we examined all this history together in one repository, it will look like: o--o--o <-- new head of origin / o--o--O--o--o--o <-- old head of origin \ \ t--t--t--m <-- their branch: Git has no way of knowing that the new head is an updated version of the old head; it treats this situation exactly the same as it would if two developers had independently done the work on the old and new heads in parallel. At this point, if someone