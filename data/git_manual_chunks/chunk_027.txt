a tree object, and you will have to resolve any such merge clashes using other tools before you can write out the result. You can examine such index state with git ls-files --unmerged command. An example: $ git read-tree -m $orig HEAD $target $ git ls-files --unmerged 100644 263414f423d0e4d70dae8fe53fa34614ff3e2860 1 hello.c 100644 06fa6a24256dc7e560efa5687fa84b51f0263c3a 2 hello.c 100644 cc44c73eb783565da5831b4d820c962954019b69 3 hello.c Each line of the git ls-files --unmerged output begins with the blob mode bits, blob SHA-1, stage number , and the filename. The stage number is Git’s way to say which tree it came from: stage 1 corresponds to the $orig tree, stage 2 to the HEAD tree, and stage 3 to the $target tree. Earlier we said that trivial merges are done inside git read-tree -m . For example, if the file did not change from $orig to HEAD or $target , or if the file changed from $orig to HEAD and $orig to $target the same way, obviously the final outcome is what is in HEAD . What the above example shows is that file hello.c was changed from $orig to HEAD and $orig to $target in a different way. You could resolve this by running your favorite 3-way merge program, e.g. diff3 , merge , or Git’s own merge-file, on the blob objects from these three stages yourself, like this: $ git cat-file blob 263414f >hello.c~1 $ git cat-file blob 06fa6a2 >hello.c~2 $ git cat-file blob cc44c73 >hello.c~3 $ git merge-file hello.c~2 hello.c~1 hello.c~3 This would leave the merge result in hello.c~2 file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by: $ mv -f hello.c~2 hello.c $ git update-index hello.c When a path is in the "unmerged" state, running git update-index for that path tells Git to mark the path resolved. The above is the description of a Git merge at the lowest level, to help you understand what conceptually happens under the hood. In practice, nobody, not even Git itself, runs git cat-file three times for this. There is a git merge-index program that extracts the stages to temporary files and calls a "merge" script on it: $ git merge-index git-merge-one-file hello.c and that is what higher level git merge -s resolve is implemented with. Hacking Git This chapter covers internal details of the Git implementation which probably only Git developers need to understand. Object storage format All objects have a statically determined "type" which identifies the format of the object (i.e. how it is used, and how it can refer to other objects). There are currently four different object types: "blob", "tree", "commit", and "tag". Regardless of object type, all objects share the following characteristics: they are all deflated with zlib, and have a header that not only specifies their type, but also provides size information about the data in the object. It’s worth noting that the SHA-1 hash that is used to name the object is the hash of the original data plus this header, so sha1sum file does not match the object name for file (the earliest versions of Git hashed slightly differently but the conclusion is still the same). The following is a short example that demonstrates how these hashes can be generated manually: Let’s assume a small text file with some simple content: $ echo "Hello world" >hello.txt We can now manually generate the hash Git would use for this file: The object we want the hash for is of type "blob" and its size is 12 bytes. Prepend the object header to the file content and feed this to sha1sum : $ { printf "blob 12\0"; cat hello.txt; } | sha1sum 802992c4220de19a90767f3000a79a31b98d0df7 - This manually constructed hash can be verified using git hash-object which of course hides the addition of the header: $ git hash-object hello.txt 802992c4220de19a90767f3000a79a31b98d0df7 As a result, the general consistency of an object can always be tested independently of the contents or the type of the object: all objects can be validated by verifying that (a) their hashes match the content of the file and (b) the object successfully inflates to a stream of bytes that forms a sequence of <ascii-type-without-space> + <space> + <ascii-decimal-size> + <byte\0> + <binary-object-data> . The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the git fsck program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash). A birds-eye view of Git’s source code It is not always easy for new developers to find their way through Git’s source code. This section gives you a little guidance to show where to start. A good place to