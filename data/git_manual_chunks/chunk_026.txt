the "parent" commits that preceded it in history. Normally a "commit" has one parent: the previous state of the tree before a certain change was made. However, sometimes it can have two or more parent commits, in which case we call it a "merge", due to the fact that such a commit brings together ("merges") two or more previous states represented by other commits. In other words, while a "tree" represents a particular directory state of a working directory, a "commit" represents that state in time, and explains how we got there. You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents: $ git commit-tree <tree> -p <parent> [(-p <parent2>)...] and then giving the reason for the commit on stdin (either through redirection from a pipe or file, or by just typing it at the tty). git commit-tree will return the name of the object that represents that commit, and you should save it away for later use. Normally, you’d commit a new HEAD state, and while Git doesn’t care where you save the note about that state, in practice we tend to just write the result to the file pointed at by .git/HEAD , so that we can always see what the last committed state was. Here is a picture that illustrates how various pieces fit together: commit-tree commit obj +----+ | | | | V V +-----------+ | Object DB | | Backing | | Store | +-----------+ ^ write-tree | | tree obj | | | | read-tree | | tree obj V +-----------+ | Index | | "cache" | +-----------+ update-index ^ blob obj | | | | checkout-index -u | | checkout-index stat | | blob obj V +-----------+ | Working | | Directory | +-----------+ Examining the data You can examine the data represented in the object database and the index with various helper tools. For every object, you can use git-cat-file[1] to examine details about the object: $ git cat-file -t <objectname> shows the type of the object, and once you have the type (which is usually implicit in where you find the object), you can use $ git cat-file blob|tree|commit|tag <objectname> to show its contents. NOTE! Trees have binary content, and as a result there is a special helper for showing that content, called git ls-tree , which turns the binary content into a more easily readable form. It’s especially instructive to look at "commit" objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in .git/HEAD , you can do $ git cat-file commit HEAD to see what the top commit was. Merging multiple trees Git can help you perform a three-way merge, which can in turn be used for a many-way merge by repeating the merge procedure several times. The usual situation is that you only do one three-way merge (reconciling two lines of history) and commit the result, but if you like to, you can merge several branches in one go. To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits. To get the "base" for the merge, look up the common parent of two commits: $ git merge-base <commit1> <commit2> This prints the name of a commit they are both based on. You should now look up the tree objects of those commits, which you can easily do with $ git cat-file commit <commitname> | head -1 since the tree object information is always the first line in a commit object. Once you know the three trees you are going to merge (the one "original" tree, aka the common tree, and the two "result" trees, aka the branches you want to merge), you do a "merge" read into the index. This will complain if it has to throw away your old index contents, so you should make sure that you’ve committed those—​in fact you would normally always do a merge against your last commit (which should thus match what you have in your current index anyway). To do the merge, do $ git read-tree -m -u <origtree> <yourtree> <targettree> which will do all trivial merge operations for you directly in the index file, and you can just write the result out with git write-tree . Merging multiple trees, continued Sadly, many merges aren’t trivial. If there are files that have been added, moved or removed, or if both branches have modified the same file, you will be left with an index tree that contains "merge entries" in it. Such an index tree can NOT be written out to