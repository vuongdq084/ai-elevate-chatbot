an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that: $ git show v2.5:fs/locks.c Before the colon may be anything that names a commit, and after it may be any path to a file tracked by Git. Examples Counting the number of commits on a branch Suppose you want to know how many commits you’ve made on mybranch since it diverged from origin : $ git log --pretty=oneline origin..mybranch | wc -l Alternatively, you may often see this sort of thing done with the lower-level command git-rev-list[1] , which just lists the SHA-1’s of all the given commits: $ git rev-list origin..mybranch | wc -l Check whether two branches point at the same history Suppose you want to check whether two branches point at the same point in history. $ git diff origin..master will tell you whether the contents of the project are the same at the two branches; in theory, however, it’s possible that the same project contents could have been arrived at by two different historical routes. You could compare the object names: $ git rev-list origin e05db0fd4f31dde7005f075a84f96b360d05984b $ git rev-list master e05db0fd4f31dde7005f075a84f96b360d05984b Or you could recall that the ... operator selects all commits reachable from either one reference or the other but not both; so $ git log origin...master will return no commits when the two branches are equal. Find first tagged version including a given fix Suppose you know that the commit e05db0fd fixed a certain problem. You’d like to find the earliest tagged release that contains that fix. Of course, there may be more than one answer—​if the history branched after commit e05db0fd, then there could be multiple "earliest" tagged releases. You could just visually inspect the commits since e05db0fd: $ gitk e05db0fd.. or you can use git-name-rev[1] , which will give the commit a name based on any tag it finds pointing to one of the commit’s descendants: $ git name-rev --tags e05db0fd e05db0fd tags/v1.5.0-rc1^0~23 The git-describe[1] command does the opposite, naming the revision using a tag on which the given commit is based: $ git describe e05db0fd v1.5.0-rc0-260-ge05db0f but that may sometimes help you guess which tags might come after the given commit. If you just want to verify whether a given tagged version contains a given commit, you could use git-merge-base[1] : $ git merge-base e05db0fd v1.5.0-rc1 e05db0fd4f31dde7005f075a84f96b360d05984b The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1. Alternatively, note that $ git log v1.5.0-rc1..e05db0fd will produce empty output if and only if v1.5.0-rc1 includes e05db0fd, because it outputs only commits that are not reachable from v1.5.0-rc1. As yet another alternative, the git-show-branch[1] command lists the commits reachable from its arguments with a display on the left-hand side that indicates which arguments that commit is reachable from. So, if you run something like $ git show-branch e05db0fd v1.5.0-rc0 v1.5.0-rc1 v1.5.0-rc2 ! [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if available ! [v1.5.0-rc0] GIT v1.5.0 preview ! [v1.5.0-rc1] GIT v1.5.0-rc1 ! [v1.5.0-rc2] GIT v1.5.0-rc2 ... then a line like + ++ [e05db0fd] Fix warnings in sha1_file.c - use C99 printf format if available shows that e05db0fd is reachable from itself, from v1.5.0-rc1, and from v1.5.0-rc2, and not from v1.5.0-rc0. Showing commits unique to a given branch Suppose you would like to see all the commits reachable from the branch head named master but not from any other head in your repository. We can list all the heads in this repository with git-show-ref[1] : $ git show-ref --heads bf62196b5e363d73353a9dcf094c59595f3153b7 refs/heads/core-tutorial db768d5504c1bb46f63ee9d6e1772bd047e05bf9 refs/heads/maint a07157ac624b2524a059a3414e99f6f44bebc1e7 refs/heads/master 24dbc180ea14dc1aebe09f14c8ecf32010690627 refs/heads/tutorial-2 1e87486ae06626c2f31eaa63d26fc0fd646c8af2 refs/heads/tutorial-fixes We can get just the branch-head names, and remove master , with the help of the standard utilities cut and grep: $ git show-ref --heads | cut -d' ' -f2 | grep -v '^refs/heads/master' refs/heads/core-tutorial refs/heads/maint refs/heads/tutorial-2 refs/heads/tutorial-fixes And then we can ask to see all the commits reachable from master but not from these other heads: $ gitk master --not $( git show-ref --heads | cut -d' ' -f2 | grep -v '^refs/heads/master' ) Obviously, endless variations are possible; for example, to see all commits reachable from some head but not from any tag in the repository: $ gitk $( git show-ref --heads ) --not $( git show-ref --tags ) (See gitrevisions[7] for explanations of commit-selecting syntax such as --not .) Creating a changelog and tarball for a software release The git-archive[1] command can create a tar or zip archive from any version of a project; for example: $ git