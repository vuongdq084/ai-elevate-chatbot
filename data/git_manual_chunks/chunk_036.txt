revision is good, or $ git bisect bad # if this revision is bad. # repeat until done. Making changes Make sure Git knows who to blame: $ cat >>~/.gitconfig <<\EOF [user] name = Your Name Comes Here email = you@yourdomain.example.com EOF Select file contents to include in the next commit, then make the commit: $ git add a.txt # updated file $ git add b.txt # new file $ git rm c.txt # old file $ git commit Or, prepare and create the commit in one step: $ git commit d.txt # use latest content only of d.txt $ git commit -a # use latest content of all tracked files Merging $ git merge test # merge branch "test" into the current branch $ git pull git://example.com/project.git master # fetch and merge in remote branch $ git pull . test # equivalent to git merge test Sharing your changes Importing or exporting patches: $ git format-patch origin..HEAD # format a patch for each commit # in HEAD but not in origin $ git am mbox # import patches from the mailbox "mbox" Fetch a branch in a different Git repository, then merge into the current branch: $ git pull git://example.com/project.git theirbranch Store the fetched branch into a local branch before merging into the current branch: $ git pull git://example.com/project.git theirbranch:mybranch After creating commits on a local branch, update the remote branch with your commits: $ git push ssh://example.com/project.git mybranch:theirbranch When remote and local branch are both named "test": $ git push ssh://example.com/project.git test Shortcut version for a frequently used remote repository: $ git remote add example ssh://example.com/project.git $ git push example test Repository maintenance Check for corruption: $ git fsck Recompress, remove unused cruft: $ git gc Appendix B: Notes and todo list for this manual Todo list This is a work in progress. The basic requirements: It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise. Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, "importing patches into a project" rather than "the git am command" Think about how to create a clear chapter dependency graph that will allow people to get to important topics without necessarily reading everything in between. Scan Documentation/ for other stuff left out; in particular: howtoâ€™s some of technical/ ? hooks list of commands in git[1] Scan email archives for other stuff left out Scan man pages to see if any assume more background than this manual provides. Add more good examples. Entire sections of just cookbook examples might be a good idea; maybe make an "advanced examples" section a standard end-of-chapter section? Include cross-references to the glossary, where appropriate. Add a section on working with other version control systems, including CVS, Subversion, and just imports of series of release tarballs. Write a chapter on using plumbing and writing scripts. Alternates, clone -reference, etc. More on recovery from repository corruption. See: https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/ https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/