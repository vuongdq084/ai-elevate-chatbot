you trust that commit, and the immutability of the history of commits tells others that they can trust the whole history. In other words, you can easily validate a whole archive by just sending out a single email that tells the people the name (SHA-1 hash) of the top commit, and digitally sign that email using something like GPG/PGP. To assist in this, Git also provides the tag object…​ Tag Object A tag object contains an object, object type, tag name, the name of the person ("tagger") who created the tag, and a message, which may contain a signature, as can be seen using git-cat-file[1] : $ git cat-file tag v1.5.0 object 437b1b20df4b356c9342dac8d38849f24ef44f27 type commit tag v1.5.0 tagger Junio C Hamano <junkio@cox.net> 1171411200 +0000 GIT 1.5.0 -----BEGIN PGP SIGNATURE----- Version: GnuPG v1.4.6 (GNU/Linux) iD8DBQBF0lGqwMbZpPMRm5oRAuRiAJ9ohBLd7s2kqjkKlq1qqC57SbnmzQCdG4ui nLE/L9aUXdWeTFPron96DLA= =2E+0 -----END PGP SIGNATURE----- See the git-tag[1] command to learn how to create and verify tag objects. (Note that git-tag[1] can also be used to create "lightweight tags", which are not tag objects at all, but just simple references whose names begin with refs/tags/ ). How Git stores objects efficiently: pack files Newly created objects are initially created in a file named after the object’s SHA-1 hash (stored in .git/objects ). Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project: $ git count-objects 6930 objects, 47620 kilobytes The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those "loose" objects. You can save space and make Git faster by moving these loose objects in to a "pack file", which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in gitformat-pack[5] . To put the loose objects into a pack, just run git repack: $ git repack Counting objects: 6020, done. Delta compression using up to 4 threads. Compressing objects: 100% (6020/6020), done. Writing objects: 100% (6020/6020), done. Total 6020 (delta 4070), reused 0 (delta 0) This creates a single "pack file" in .git/objects/pack/ containing all currently unpacked objects. You can then run $ git prune to remove any of the "loose" objects that are now contained in the pack. This will also remove any unreferenced objects (which may be created when, for example, you use git reset to remove a commit). You can verify that the loose objects are gone by looking at the .git/objects directory or by running $ git count-objects 0 objects, 0 kilobytes Although the object files are gone, any commands that refer to those objects will work exactly as they did before. The git-gc[1] command performs packing, pruning, and more for you, so is normally the only high-level command you need. Dangling objects The git-fsck[1] command will sometimes complain about dangling objects. They are not a problem. The most common cause of dangling objects is that you’ve rebased a branch, or you have pulled from somebody else who rebased a branch—​see Rewriting history and maintaining patch series . In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn’t, since you replaced it with another one. There are also other situations that cause dangling objects. For example, a "dangling blob" may arise because you did a git add of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that updated thing—​the old state that you added originally ends up not being pointed to by any commit or tree, so it’s now a dangling blob object. Similarly, when the "ort" merge strategy runs, and finds that there are criss-cross merges and thus more than one merge base (which is fairly unusual, but it does happen), it will generate one temporary midway tree (or possibly even more, if you had lots of criss-crossing merges and more than two merge bases) as a temporary internal merge base, and again, those are real objects, but the end result will not end up pointing to them, so they end up "dangling" in your repository. Generally, dangling objects aren’t anything to worry about. They can even be very useful: if you screw something up, the dangling objects can be how you recover your old tree (say, you did a rebase, and realized that you really didn’t want to—​you can look at what dangling objects you have, and decide to reset your head to some old dangling state). For commits, you can just use: $ gitk <dangling-commit-sha-goes-here> --not --all This asks for all the history reachable from the given commit but not from any branch, tag, or other reference. If you decide