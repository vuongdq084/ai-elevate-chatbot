changes, but states, it really does not make sense to use the term "changesets" with Git. checkout The action of updating all or part of the working tree with a tree object or blob from the object database , and updating the index and HEAD if the whole working tree has been pointed at a new branch . cherry-picking In SCM jargon, "cherry pick" means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the "git cherry-pick" command to extract the change introduced by an existing commit and to record it based on the tip of the current branch as a new commit. clean A working tree is clean, if it corresponds to the revision referenced by the current head . Also see " dirty ". commit As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word "commit" is often used by Git in the same places other revision control systems use the words "revision" or "version". Also used as a short hand for commit object . As a verb: The action of storing a new snapshot of the project’s state in the Git history, by creating a new commit representing the current state of the index and advancing HEAD to point at the new commit. commit graph concept, representations and usage A synonym for the DAG structure formed by the commits in the object database, referenced by branch tips, using their chain of linked commits. This structure is the definitive commit graph. The graph can be represented in other ways, e.g. the "commit-graph" file . commit-graph file The "commit-graph" (normally hyphenated) file is a supplemental representation of the commit graph which accelerates commit graph walks. The "commit-graph" file is stored either in the .git/objects/info directory or in the info directory of an alternate object database. commit object An object which contains the information about a particular revision , such as parents , committer, author, date and the tree object which corresponds to the top directory of the stored revision. commit-ish (also committish) A commit object or an object that can be recursively dereferenced to a commit object. The following are all commit-ishes: a commit object, a tag object that points to a commit object, a tag object that points to a tag object that points to a commit object, etc. core Git Fundamental data structures and utilities of Git. Exposes only limited source code management tools. DAG Directed acyclic graph. The commit objects form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no chain which begins and ends with the same object ). dangling object An unreachable object which is not reachable even from other unreachable objects; a dangling object has no references to it from any reference or object in the repository . dereference Referring to a symbolic ref : the action of accessing the reference pointed at by a symbolic ref. Recursive dereferencing involves repeating the aforementioned process on the resulting ref until a non-symbolic reference is found. Referring to a tag object : the action of accessing the object a tag points at. Tags are recursively dereferenced by repeating the operation on the result object until the result has either a specified object type (where applicable) or any non-"tag" object type. A synonym for "recursive dereference" in the context of tags is " peel ". Referring to a commit object : the action of accessing the commit’s tree object. Commits cannot be dereferenced recursively. Unless otherwise specified, "dereferencing" as it used in the context of Git commands or protocols is implicitly recursive. detached HEAD Normally the HEAD stores the name of a branch , and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to check out an arbitrary commit that isn’t necessarily the tip of any particular branch. The HEAD in such a state is called "detached". Note that commands that operate on the history of the current branch (e.g. git commit to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information about the current branch (e.g. git branch --set-upstream-to that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state. directory The list you get with "ls"