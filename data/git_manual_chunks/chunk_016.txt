branch case "$1" in test|release) git checkout $1 && git pull . origin ;; origin) before=$(git rev-parse refs/remotes/origin/master) git fetch origin after=$(git rev-parse refs/remotes/origin/master) if [ $before != $after ] then git log $before..$after | git shortlog fi ;; *) echo "usage: $0 origin|test|release" 1>&2 exit 1 ;; esac ==== merge script ==== # Merge a branch into either the test or release branch pname=$0 usage() { echo "usage: $pname branch test|release" 1>&2 exit 1 } git show-ref -q --verify -- refs/heads/"$1" || { echo "Can't see branch <$1>" 1>&2 usage } case "$2" in test|release) if [ $(git log $2..$1 | wc -c) -eq 0 ] then echo $1 already merged into $2 1>&2 exit 1 fi git checkout $2 && git pull . $1 ;; *) usage ;; esac ==== status script ==== # report on status of my ia64 Git tree gb=$(tput setab 2) rb=$(tput setab 1) restore=$(tput setab 9) if [ `git rev-list test..release | wc -c` -gt 0 ] then echo $rb Warning: commits in release that are not in test $restore git log test..release fi for branch in `git show-ref --heads | sed 's|^.*/||'` do if [ $branch = test -o $branch = release ] then continue fi echo -n $gb ======= $branch ====== $restore " " status= for ref in test release origin/master do if [ `git rev-list $ref..$branch | wc -c` -gt 0 ] then status=$status${ref:0:1} fi done case $status in trl) echo $rb Need to pull into test $restore ;; rl) echo "In test" ;; l) echo "Waiting for linus" ;; "") echo $rb All done $restore ;; *) echo $rb "<$status>" $restore ;; esac git log origin/master..$branch | git shortlog done Rewriting history and maintaining patch series Normally commits are only added to a project, never taken away or replaced. Git is designed with this assumption, and violating it will cause Git’s merge machinery (for example) to do the wrong thing. However, there is a situation in which it can be useful to violate this assumption. Creating the perfect patch series Suppose you are a contributor to a large project, and you want to add a complicated feature, and to present it to the other developers in a way that makes it easy for them to read your changes, verify that they are correct, and understand why you made each change. If you present all of your changes as a single patch (or commit), they may find that it is too much to digest all at once. If you present them with the entire history of your work, complete with mistakes, corrections, and dead ends, they may be overwhelmed. So the ideal is usually to produce a series of patches such that: Each patch can be applied in order. Each patch includes a single logical change, together with a message explaining the change. No patch introduces a regression: after applying any initial part of the series, the resulting project still compiles and works, and has no bugs that it didn’t have before. The complete series produces the same end result as your own (probably much messier!) development process did. We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history. Keeping a patch series up to date using git rebase Suppose that you create a branch mywork on a remote-tracking branch origin , and create some commits on top of it: $ git switch -c mywork origin $ vi file.txt $ git commit $ vi otherfile.txt $ git commit ... You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of origin : o--o--O <-- origin \ a--b--c <-- mywork Some more interesting work has been done in the upstream project, and origin has advanced: o--o--O--o--o--o <-- origin \ a--b--c <-- mywork At this point, you could use pull to merge your changes back in; the result would create a new merge commit, like this: o--o--O--o--o--o <-- origin \ \ a--b--c--m <-- mywork However, if you prefer to keep the history in mywork a simple series of commits without any merges, you may instead choose to use git-rebase[1] : $ git switch mywork $ git rebase origin This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named .git/rebase-apply ), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like: o--o--O--o--o--o <-- origin \ a'--b'--c' <-- mywork In the process, it may discover conflicts. In that case it will stop and allow you to fix the conflicts; after fixing conflicts, use git add to update the index with