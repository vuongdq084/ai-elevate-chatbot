and the index to match the tip of your current branch. Then you can make your fix as usual. ... edit and test ... $ git commit -a -m "blorpl: typofix" After that, you can go back to what you were working on with git stash pop : $ git stash pop Ensuring good performance On large repositories, Git depends on compression to keep the history information from taking up too much space on disk or in memory. Some Git commands may automatically run git-gc[1] , so you don’t have to worry about running it manually. However, compressing a large repository may take a while, so you may want to call gc explicitly to avoid automatic compression kicking in when it is not convenient. Ensuring reliability Checking the repository for corruption The git-fsck[1] command runs a number of self-consistency checks on the repository, and reports on any problems. This may take some time. $ git fsck dangling commit 7281251ddd2a61e38657c827739c57015671a6b3 dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63 dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5 dangling blob 218761f9d90712d37a9c5e36f406f92202db07eb dangling commit bf093535a34a4d35731aa2bd90fe6b176302f14f dangling commit 8e4bec7f2ddaa268bef999853c25755452100f8e dangling tree d50bb86186bf27b681d25af89d3b5b68382e4085 dangling tree b24c2473f1fd3d91352a624795be026d64c8841f ... You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with gc . You can run git fsck --no-dangling to suppress these messages, and still view real errors. Recovering lost changes Reflogs Say you modify a branch with git reset --hard , and then realize that the branch was the only reference you had to that point in history. Fortunately, Git also keeps a log, called a "reflog", of all the previous values of each branch. So in this case you can still find the old history using, for example, $ git log master@{1} This lists the commits reachable from the previous version of the master branch head. This syntax can be used with any Git command that accepts a commit, not just with git log . Some other examples: $ git show master@{2} # See where the branch pointed 2, $ git show master@{3} # 3, ... changes ago. $ gitk master@{yesterday} # See where it pointed yesterday, $ gitk master@{"1 week ago"} # ... or last week $ git log --walk-reflogs master # show reflog entries for master A separate reflog is kept for the HEAD, so $ git show HEAD@{"1 week ago"} will show what HEAD pointed to one week ago, not what the current branch pointed to one week ago. This allows you to see the history of what you’ve checked out. The reflogs are kept by default for 30 days, after which they may be pruned. See git-reflog[1] and git-gc[1] to learn how to control this pruning, and see the "SPECIFYING REVISIONS" section of gitrevisions[7] for details. Note that the reflog history is very different from normal Git history. While normal history is shared by every repository that works on the same project, the reflog history is not shared: it tells you only about how the branches in your local repository have changed over time. Examining dangling objects In some situations the reflog may not be able to save you. For example, suppose you delete a branch, then realize you need the history it contained. The reflog is also deleted; however, if you have not yet pruned the repository, then you may still be able to find the lost commits in the dangling objects that git fsck reports. See Dangling objects for the details. $ git fsck dangling commit 7281251ddd2a61e38657c827739c57015671a6b3 dangling commit 2706a059f258c6b245f298dc4ff2ccd30ec21a63 dangling commit 13472b7c4b80851a1bc551779171dcb03655e9b5 ... You can examine one of those dangling commits with, for example, $ gitk 7281251ddd --not --all which does what it sounds like: it says that you want to see the commit history that is described by the dangling commit(s), but not the history that is described by all your existing branches and tags. Thus you get exactly the history reachable from that commit that is lost. (And notice that it might not be just one commit: we only report the "tip of the line" as being dangling, but there might be a whole deep and complex commit history that was dropped.) If you decide you want the history back, you can always create a new reference pointing to it, for example, a new branch: $ git branch recovered-branch 7281251ddd Other types of dangling objects (blobs and trees) are also possible, and dangling objects can arise in other situations. Sharing development with others Getting updates with git pull After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates and merge them into your own work. We have already seen how to keep remote-tracking branches up to date with git-fetch[1]