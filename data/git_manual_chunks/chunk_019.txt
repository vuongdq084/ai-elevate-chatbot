old head of the branch \ o--o--o <-- new head of the branch In this case, git fetch will fail, and print out a warning. In that case, you can still force Git to update to the new head, as described in the following section. However, note that in the situation above this may mean losing the commits labeled a and b , unless you’ve already created a reference of your own pointing to them. Forcing git fetch to do non-fast-forward updates If git fetch fails because the new head of a branch is not a descendant of the old head, you may force the update with: $ git fetch git://example.com/proj.git +master:refs/remotes/example/master Note the addition of the + sign. Alternatively, you can use the -f flag to force updates of all the fetched branches, as in: $ git fetch -f origin Be aware that commits that the old version of example/master pointed at may be lost, as we saw in the previous section. Configuring remote-tracking branches We saw above that origin is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using git-config[1] : $ git config -l core.repositoryformatversion=0 core.filemode=true core.logallrefupdates=true remote.origin.url=git://git.kernel.org/pub/scm/git/git.git remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* branch.master.remote=origin branch.master.merge=refs/heads/master If there are other repositories that you also use frequently, you can create similar configuration options to save typing; for example, $ git remote add example git://example.com/proj.git adds the following to .git/config : [remote "example"] url = git://example.com/proj.git fetch = +refs/heads/*:refs/remotes/example/* Also note that the above configuration can be performed by directly editing the file .git/config instead of using git-remote[1] . After configuring the remote, the following three commands will do the same thing: $ git fetch git://example.com/proj.git +refs/heads/*:refs/remotes/example/* $ git fetch example +refs/heads/*:refs/remotes/example/* $ git fetch example See git-config[1] for more details on the configuration options mentioned above and git-fetch[1] for more details on the refspec syntax. Git concepts Git is built on a small number of simple but powerful ideas. While it is possible to get things done without understanding them, you will find Git much more intuitive if you do. We start with the most important, the object database and the index . The Object Database We already saw in Understanding History: Commits that all commits are stored under a 40-digit "object name". In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others: Git can quickly determine whether two objects are identical or not, just by comparing names. Since object names are computed the same way in every repository, the same content stored in two repositories will always be stored under the same name. Git can detect errors when it reads an object, by checking that the object’s name is still the SHA-1 hash of its contents. (See Object storage format for the details of the object formatting and SHA-1 calculation.) There are four different types of objects: "blob", "tree", "commit", and "tag". A "blob" object is used to store file data. A "tree" object ties one or more "blob" objects into a directory structure. In addition, a tree object can refer to other tree objects, thus creating a directory hierarchy. A "commit" object ties such directory hierarchies together into a directed acyclic graph of revisions—​each commit contains the object name of exactly one tree designating the directory hierarchy at the time of the commit. In addition, a commit refers to "parent" commit objects that describe the history of how we arrived at that directory hierarchy. A "tag" object symbolically identifies and can be used to sign other objects. It contains the object name and type of another object, a symbolic name (of course!) and, optionally, a signature. The object types in some more detail: Commit Object The "commit" object links a physical state of a tree with a description of how we got there and why. Use the --pretty=raw option to git-show[1] or git-log[1] to examine your favorite commit: $ git show -s --pretty=raw 2be7fcb476 commit 2be7fcb4764f2dbcee52635b91fedb1b3dcf7ab4 tree fb3a8bdd0ceddd019615af4d57a53f43d8cee2bf parent 257a84d9d02e90447b149af58b271c19405edb6a author Dave Watson <dwatson@mimvista.com> 1187576872 -0400 committer Junio C Hamano <gitster@pobox.com> 1187591163 -0700 Fix misspelling of 'suppress' in docs Signed-off-by: Junio C Hamano <gitster@pobox.com> As you can see, a commit is defined by: a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time. parent(s): The SHA-1 name(s) of some number of commits which represent the immediately previous