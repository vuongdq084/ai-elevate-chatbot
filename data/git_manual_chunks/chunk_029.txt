Git (after you know the basic concepts). So, think about something which you are interested in, say, "how can I access a blob just knowing the object name of it?". The first step is to find a Git command with which you can do it. In this example, it is either git show or git cat-file . For the sake of clarity, let’s stay with git cat-file , because it is plumbing, and was around even in the initial commit (it literally went only through some 20 revisions as cat-file.c , was renamed to builtin/cat-file.c when made a builtin, and then saw less than 10 versions). So, look into builtin/cat-file.c , search for cmd_cat_file () and look what it does. git_config(git_default_config); if (argc != 3) usage("git cat-file [-t|-s|-e|-p|<type>] <sha1>"); if (get_sha1(argv[2], sha1)) die("Not a valid object name %s", argv[2]); Let’s skip over the obvious details; the only really interesting part here is the call to get_sha1 () . It tries to interpret argv [ 2 ] as an object name, and if it refers to an object which is present in the current repository, it writes the resulting SHA-1 into the variable sha1 . Two things are interesting here: get_sha1 () returns 0 on success . This might surprise some new Git hackers, but there is a long tradition in UNIX to return different negative numbers in case of different errors—​and 0 on success. the variable sha1 in the function signature of get_sha1 () is unsigned char * , but is actually expected to be a pointer to unsigned char [ 20 ] . This variable will contain the 160-bit SHA-1 of the given commit. Note that whenever a SHA-1 is passed as unsigned char * , it is the binary representation, as opposed to the ASCII representation in hex characters, which is passed as char * . You will see both of these things throughout the code. Now, for the meat: case 0: buf = read_object_with_reference(sha1, argv[1], &size, NULL); This is how you read a blob (actually, not only a blob, but any type of object). To know how the function read_object_with_reference () actually works, find the source code for it (something like git grep read_object_with | grep ": [ a-z ] " in the Git repository), and read the source. To find out how the result can be used, just read on in cmd_cat_file () : write_or_die(1, buf, size); Sometimes, you do not know where to look for a feature. In many such cases, it helps to search through the output of git log , and then git show the corresponding commit. Example: If you know that there was some test case for git bundle , but do not remember where it was (yes, you could git grep bundle t/ , but that does not illustrate the point!): $ git log --no-merges t/ In the pager ( less ), just search for "bundle", go a few lines back, and see that it is in commit 18449ab0. Now just copy this object name, and paste it into the command line $ git show 18449ab0 Voila. Another example: Find out what to do in order to make some script a builtin: $ git log --no-merges --diff-filter=A builtin/*.c You see, Git is actually the best tool to find out about the source of Git itself! Git Glossary Git explained alternate object database Via the alternates mechanism, a repository can inherit part of its object database from another object database, which is called an "alternate". bare repository A bare repository is normally an appropriately named directory with a .git suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the Git administrative and control files that would normally be present in the hidden .git sub-directory are directly present in the repository.git directory instead, and no other files are present and checked out. Usually publishers of public repositories make bare repositories available. blob object Untyped object , e.g. the contents of a file. branch A "branch" is a line of development. The most recent commit on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch head , which moves forward as additional development is done on the branch. A single Git repository can track an arbitrary number of branches, but your working tree is associated with just one of them (the "current" or "checked out" branch), and HEAD points to that branch. cache Obsolete for: index . chain A list of objects, where each object in the list contains a reference to its successor (for example, the successor of a commit could be one of its parents ). changeset BitKeeper/cvsps speak for " commit ". Since Git does not store